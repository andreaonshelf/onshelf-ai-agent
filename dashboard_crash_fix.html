<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Crash Fix - Minimal Test</title>
    
    <!-- React and Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .error {
            background: #fee;
            border: 1px solid #fcc;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            color: #c00;
        }
        .success {
            background: #efe;
            border: 1px solid #cfc;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            color: #060;
        }
        select {
            padding: 8px;
            font-size: 16px;
            margin: 10px 0;
            width: 100%;
            max-width: 300px;
        }
        pre {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            max-height: 400px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;
        
        function CrashDebugApp() {
            const [selectedType, setSelectedType] = useState('');
            const [fields, setFields] = useState([]);
            const [error, setError] = useState(null);
            const [loading, setLoading] = useState(false);
            const [debugInfo, setDebugInfo] = useState('');
            
            // Mock extraction types - replace with actual data source
            const extractionTypes = [
                { value: 'product_v1', label: 'Product v1' },
                { value: 'shelf_v1', label: 'Shelf v1' },
                { value: 'price_v1', label: 'Price v1' },
                { value: 'custom', label: 'Custom' }
            ];
            
            // Safe field loading with error handling
            const loadFieldsSafely = useCallback(async (type) => {
                if (!type) {
                    setFields([]);
                    return;
                }
                
                setLoading(true);
                setError(null);
                setDebugInfo(`Loading fields for: ${type}`);
                
                try {
                    // For now, use mock data to test
                    const mockFields = {
                        'product_v1': [
                            { name: 'product_name', type: 'string', description: 'Product name', required: true },
                            { name: 'brand', type: 'string', description: 'Brand name', required: true },
                            { name: 'price', type: 'float', description: 'Product price', required: false },
                            { 
                                name: 'details', 
                                type: 'object', 
                                description: 'Product details',
                                nested_fields: [
                                    { name: 'size', type: 'string', description: 'Product size' },
                                    { name: 'weight', type: 'float', description: 'Product weight' }
                                ]
                            }
                        ],
                        'shelf_v1': [
                            { name: 'shelf_number', type: 'integer', description: 'Shelf number', required: true },
                            { name: 'position', type: 'string', description: 'Position on shelf', required: true }
                        ],
                        'price_v1': [
                            { name: 'regular_price', type: 'float', description: 'Regular price', required: true },
                            { name: 'sale_price', type: 'float', description: 'Sale price', required: false }
                        ],
                        'custom': []
                    };
                    
                    // Simulate API call delay
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Get fields for the selected type
                    const typeFields = mockFields[type] || [];
                    
                    // Validate fields to prevent circular references
                    const validateFields = (fields, visited = new Set(), path = []) => {
                        for (const field of fields) {
                            const fieldKey = `${field.name}-${field.type}`;
                            if (visited.has(fieldKey)) {
                                throw new Error(`Circular reference detected at: ${path.join(' > ')} > ${field.name}`);
                            }
                            
                            visited.add(fieldKey);
                            
                            if (field.nested_fields && Array.isArray(field.nested_fields)) {
                                validateFields(
                                    field.nested_fields, 
                                    new Set(visited), 
                                    [...path, field.name]
                                );
                            }
                            
                            visited.delete(fieldKey);
                        }
                    };
                    
                    // Validate the fields
                    validateFields(typeFields);
                    
                    // Check for excessive nesting
                    const checkNestingDepth = (fields, depth = 0, maxDepth = 5) => {
                        if (depth > maxDepth) {
                            throw new Error(`Field nesting exceeds maximum depth of ${maxDepth}`);
                        }
                        
                        for (const field of fields) {
                            if (field.nested_fields && Array.isArray(field.nested_fields)) {
                                checkNestingDepth(field.nested_fields, depth + 1, maxDepth);
                            }
                        }
                    };
                    
                    checkNestingDepth(typeFields);
                    
                    setFields(typeFields);
                    setDebugInfo(`Successfully loaded ${typeFields.length} fields for ${type}`);
                    
                } catch (err) {
                    console.error('Error loading fields:', err);
                    setError(`Error: ${err.message}`);
                    setFields([]);
                    setDebugInfo(`Failed to load fields: ${err.message}`);
                } finally {
                    setLoading(false);
                }
            }, []);
            
            // Handle type selection change
            const handleTypeChange = (e) => {
                const newType = e.target.value;
                setSelectedType(newType);
                loadFieldsSafely(newType);
            };
            
            // Render fields safely
            const renderFields = (fields, level = 0) => {
                return fields.map((field, index) => (
                    <div key={`${field.name}-${index}`} style={{ marginLeft: `${level * 20}px`, marginBottom: '10px' }}>
                        <div style={{ 
                            padding: '8px', 
                            background: level === 0 ? '#f0f0f0' : '#f8f8f8',
                            borderRadius: '4px',
                            border: '1px solid #ddd'
                        }}>
                            <strong>{field.name}</strong> ({field.type})
                            {field.required && <span style={{ color: 'red' }}> *</span>}
                            <div style={{ fontSize: '14px', color: '#666' }}>{field.description}</div>
                        </div>
                        {field.nested_fields && Array.isArray(field.nested_fields) && (
                            <div style={{ marginTop: '5px' }}>
                                {renderFields(field.nested_fields, level + 1)}
                            </div>
                        )}
                    </div>
                ));
            };
            
            return (
                <div className="container">
                    <h1>Dashboard Crash Debug</h1>
                    
                    <div>
                        <label htmlFor="extraction-type">Select Extraction Type:</label>
                        <br />
                        <select 
                            id="extraction-type"
                            value={selectedType} 
                            onChange={handleTypeChange}
                        >
                            <option value="">-- Select Type --</option>
                            {extractionTypes.map(type => (
                                <option key={type.value} value={type.value}>
                                    {type.label}
                                </option>
                            ))}
                        </select>
                    </div>
                    
                    {loading && <div style={{ margin: '20px 0' }}>Loading fields...</div>}
                    
                    {error && <div className="error">{error}</div>}
                    
                    {debugInfo && <div className="success">{debugInfo}</div>}
                    
                    {!loading && fields.length > 0 && (
                        <div style={{ marginTop: '20px' }}>
                            <h2>Fields for {selectedType}:</h2>
                            {renderFields(fields)}
                        </div>
                    )}
                    
                    {!loading && fields.length > 0 && (
                        <div style={{ marginTop: '20px' }}>
                            <h3>Raw Field Data:</h3>
                            <pre>{JSON.stringify(fields, null, 2)}</pre>
                        </div>
                    )}
                </div>
            );
        }
        
        ReactDOM.render(<CrashDebugApp />, document.getElementById('root'));
    </script>
</body>
</html>